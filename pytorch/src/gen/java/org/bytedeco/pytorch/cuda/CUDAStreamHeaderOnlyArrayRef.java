// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch.cuda;

import org.bytedeco.pytorch.Allocator;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;
import org.bytedeco.pytorch.*;
import static org.bytedeco.pytorch.global.torch.*;
import org.bytedeco.cuda.cudart.*;
import static org.bytedeco.cuda.global.cudart.*;
import org.bytedeco.cuda.cublas.*;
import static org.bytedeco.cuda.global.cublas.*;
import org.bytedeco.cuda.cudnn.*;
import static org.bytedeco.cuda.global.cudnn.*;
import org.bytedeco.cuda.cusparse.*;
import static org.bytedeco.cuda.global.cusparse.*;
import org.bytedeco.cuda.cusolver.*;
import static org.bytedeco.cuda.global.cusolver.*;
import org.bytedeco.cuda.cupti.*;
import static org.bytedeco.cuda.global.cupti.*;

import static org.bytedeco.pytorch.global.torch_cuda.*;


/** HeaderOnlyArrayRef - A subset of ArrayRef that is implemented only
 *  in headers. This will be a base class from which ArrayRef inherits, so that
 *  we can keep much of the implementation shared.
 * 
 *  [HeaderOnlyArrayRef vs ArrayRef note]
 *  As HeaderOnlyArrayRef is a subset of ArrayRef, it has slightly less
 *  functionality than ArrayRef. We document the minor differences below:
 *  1. ArrayRef has an extra convenience constructor for SmallVector.
 *  2. ArrayRef uses TORCH_CHECK. HeaderOnlyArrayRef uses header-only
 *     STD_TORCH_CHECK, which will output a std::runtime_error vs a
 *     c10::Error. Consequently, you should use ArrayRef when possible
 *     and HeaderOnlyArrayRef only when necessary to support headeronly code.
 *  In all other aspects, HeaderOnlyArrayRef is identical to ArrayRef, with the
 *  positive benefit of being header-only and thus independent of libtorch.so. */
@Name("c10::HeaderOnlyArrayRef<c10::cuda::CUDAStream>") @NoOffset @Properties(inherit = org.bytedeco.pytorch.presets.torch_cuda.class)
public class CUDAStreamHeaderOnlyArrayRef extends Pointer {
    static { Loader.load(); }
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public CUDAStreamHeaderOnlyArrayRef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public CUDAStreamHeaderOnlyArrayRef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public CUDAStreamHeaderOnlyArrayRef position(long position) {
        return (CUDAStreamHeaderOnlyArrayRef)super.position(position);
    }
    @Override public CUDAStreamHeaderOnlyArrayRef getPointer(long i) {
        return new CUDAStreamHeaderOnlyArrayRef((Pointer)this).offsetAddress(i);
    }

  /** \name Constructors
   *  \{
   <p>
   *  Construct an empty HeaderOnlyArrayRef. */
  /* implicit */ public CUDAStreamHeaderOnlyArrayRef() { super((Pointer)null); allocate(); }
private native void allocate();

  /** Construct a HeaderOnlyArrayRef from a single element. */
  // TODO Make this explicit
  

  /** Construct a HeaderOnlyArrayRef from a pointer and length. */
  public CUDAStreamHeaderOnlyArrayRef(@Const CUDAStream data, @Cast("size_t") long length) { super((Pointer)null); allocate(data, length); }
  private native void allocate(@Const CUDAStream data, @Cast("size_t") long length);

  /** Construct a HeaderOnlyArrayRef from a range. */
  public CUDAStreamHeaderOnlyArrayRef(@Const CUDAStream begin, @Const CUDAStream end) { super((Pointer)null); allocate(begin, end); }
  private native void allocate(@Const CUDAStream begin, @Const CUDAStream end);

  /** Construct a HeaderOnlyArrayRef from a std::vector. */
  // The enable_if stuff here makes sure that this isn't used for
  // std::vector<bool>, because ArrayRef can't work on a std::vector<bool>
  // bitfield.

  /** Construct a HeaderOnlyArrayRef from a std::array */

  /** Construct a HeaderOnlyArrayRef from a C array. */

  /** Construct a HeaderOnlyArrayRef from a std::initializer_list. */
  /* implicit */

  /** \}
   *  \name Simple Operations
   *  \{ */

  
  

  // These are actually the same as iterator, since ArrayRef only
  // gives you const iterators.
  
  

  /** Check if all elements in the array satisfy the given expression */
  

  /** empty - Check if the array is empty. */
  public native @Cast("const bool") boolean empty();

  public native @Const CUDAStream data();

  /** size - Get the array size. */
  public native @Cast("const size_t") long size();

  /** front - Get the first element. */
  public native @Const @ByRef CUDAStream front();

  /** back - Get the last element. */
  public native @Const @ByRef CUDAStream back();

  /** equals - Check for element-wise equality. */
  

  /** slice(n, m) - Take M elements of the array starting at element N */
  public native @Const @ByVal CUDAStreamHeaderOnlyArrayRef slice(@Cast("size_t") long N, @Cast("size_t") long M);

  /** slice(n) - Chop off the first N elements of the array. */
  public native @Const @ByVal CUDAStreamHeaderOnlyArrayRef slice(@Cast("size_t") long N);

  /** \}
   *  \name Operator Overloads
   *  \{ */
  public native @Const @ByRef @Name("operator []") CUDAStream get(@Cast("size_t") long Index);

  /** Vector compatibility */
  
  ///
  public native @Const @ByRef CUDAStream at(@Cast("size_t") long Index);

  /** Disallow accidental assignment from a temporary.
   * 
   *  The declaration here is extra complicated so that "arrayRef = {}"
   *  continues to select the move assignment operator. */
  

  /** Disallow accidental assignment from a temporary.
   * 
   *  The declaration here is extra complicated so that "arrayRef = {}"
   *  continues to select the move assignment operator. */
  

  /** \}
   *  \name Expensive Operations
   *  \{ */
  public native @StdVector CUDAStream vec();

  /** \} */
}
