// Targeted by JavaCPP version 1.5.13-SNAPSHOT: DO NOT EDIT THIS FILE

package org.bytedeco.pytorch;

import org.bytedeco.pytorch.Allocator;
import org.bytedeco.pytorch.Function;
import org.bytedeco.pytorch.Module;
import org.bytedeco.javacpp.annotation.Cast;
import java.nio.*;
import org.bytedeco.javacpp.*;
import org.bytedeco.javacpp.annotation.*;

import static org.bytedeco.javacpp.presets.javacpp.*;
import static org.bytedeco.openblas.global.openblas_nolapack.*;
import static org.bytedeco.openblas.global.openblas.*;
import org.bytedeco.javacpp.chrono.*;
import static org.bytedeco.javacpp.global.chrono.*;

import static org.bytedeco.pytorch.global.torch.*;

/** ArrayRef - Represent a constant reference to an array (0 or more elements
 *  consecutively in memory), i.e. a start pointer and a length.  It allows
 *  various APIs to take consecutive elements easily and conveniently.
 * 
 *  This class does not own the underlying data, it is expected to be used in
 *  situations where the data resides in some other buffer, whose lifetime
 *  extends past that of the ArrayRef. For this reason, it is not in general
 *  safe to store an ArrayRef.
 * 
 *  This is intended to be trivially copyable, so it should be passed by
 *  value.
 * 
 *  NOTE: We have refactored out the headeronly parts of the ArrayRef struct
 *  into HeaderOnlyArrayRef. As adding {@code virtual} would change the performance of
 *  the underlying constexpr calls, we rely on apparent-type dispatch for
 *  inheritance. This should be fine because their memory format is the same,
 *  and it is never incorrect for ArrayRef to call HeaderOnlyArrayRef methods.
 *  However, you should prefer to use ArrayRef when possible, because its use
 *  of TORCH_CHECK will lead to better user-facing error messages. */
@Name("c10::ArrayRef<c10::Argument>") @Properties(inherit = org.bytedeco.pytorch.presets.torch.class)
public class ArgumentArrayRef extends ArgumentHeaderOnlyArrayRef {
    static { Loader.load(); }


   public ArgumentArrayRef() { super((Pointer)null); allocate(); }
  private native void allocate();
    public ArgumentArrayRef(@Const Argument data, @Cast("size_t") long length) { super((Pointer)null); allocate(data, length); }
    private native void allocate(@Const Argument data, @Cast("size_t") long length);
    public ArgumentArrayRef(@Const Argument begin, @Const Argument end) { super((Pointer)null); allocate(begin, end); }
    private native void allocate(@Const Argument begin, @Const Argument end);
    /** Pointer cast constructor. Invokes {@link Pointer#Pointer(Pointer)}. */
    public ArgumentArrayRef(Pointer p) { super(p); }
    /** Native array allocator. Access with {@link Pointer#position(long)}. */
    public ArgumentArrayRef(long size) { super((Pointer)null); allocateArray(size); }
    private native void allocateArray(long size);
    @Override public ArgumentArrayRef position(long position) {
        return (ArgumentArrayRef)super.position(position);
    }
    @Override public ArgumentArrayRef getPointer(long i) {
        return new ArgumentArrayRef((Pointer)this).offsetAddress(i);
    }

  /** \name Constructors, all inherited from HeaderOnlyArrayRef except for
   *  SmallVector. As inherited constructors won't work with class template
   *  argument deduction (CTAD) until C++23, we add deduction guides after
   *  the class definition to enable CTAD.
   *  \{ */

  /** Construct an ArrayRef from a SmallVector. This is templated in order to
   *  avoid instantiating SmallVectorTemplateCommon<T> whenever we
   *  copy-construct an ArrayRef.
   *  NOTE: this is the only constructor that is not inherited from
   *  HeaderOnlyArrayRef. */

  /** \}
   *  \name Simple Operations, mostly inherited from HeaderOnlyArrayRef
   *  \{
   <p>
   *  front - Get the first element.
   *  We deviate from HeaderOnlyArrayRef by using TORCH_CHECK instead of
   *  STD_TORCH_CHECK */
  public native @Const @ByRef Argument front();

  /** back - Get the last element.
   *  We deviate from HeaderOnlyArrayRef by using TORCH_CHECK instead of
   *  STD_TORCH_CHECK */
  public native @Const @ByRef Argument back();

  /** slice(n, m) - Take M elements of the array starting at element N
   *  We deviate from HeaderOnlyArrayRef by using TORCH_CHECK instead of
   *  STD_TORCH_CHECK */
  public native @Const @ByVal ArgumentArrayRef slice(@Cast("size_t") long N, @Cast("size_t") long M);

  /** slice(n) - Chop off the first N elements of the array.
   *  We deviate from HeaderOnlyArrayRef by using TORCH_CHECK instead of
   *  STD_TORCH_CHECK */
  public native @Const @ByVal ArgumentArrayRef slice(@Cast("size_t") long N);

  /** \}
   *  \name Operator Overloads
   *  \{
   <p>
   *  Vector compatibility
   *  We deviate from HeaderOnlyArrayRef by using TORCH_CHECK instead of
   *  STD_TORCH_CHECK */
  
  ///
  public native @Const @ByRef Argument at(@Cast("size_t") long Index);

  /** Disallow accidental assignment from a temporary.
   * 
   *  The declaration here is extra complicated so that "arrayRef = {}"
   *  continues to select the move assignment operator. */
  

  /** Disallow accidental assignment from a temporary.
   * 
   *  The declaration here is extra complicated so that "arrayRef = {}"
   *  continues to select the move assignment operator. */
  

  /** \} */
}
